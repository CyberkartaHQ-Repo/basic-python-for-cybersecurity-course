# Network Recon & Exploit

*Basic Python for Cybersecurity*

*© 2025 Yogi Agnia Dwi Saputro dan PT. Cyberkarta Tugu Teknologi.*

Dilarang keras memperbanyak, menyalin, mendistribusikan, atau menggunakan sebagian atau seluruh isi karya ini dalam bentuk apapun tanpa izin tertulis dari pemegang hak cipta.

------------------------------------

## Praktik Website Recon & Exploit Umum

1. Ping Sweep
2. Port Scanning
3. SSH Brute Force
4. Shodan API Implementation
5. Network Sniffing

### Setup Awal

- Setup SSH (Localhost)
  - Instalasi openSSH: `sudo apt update && sudo apt install openssh-server -y`
  - Jalankan service `ssh` di background: `sudo service ssh start`
  - Cek service `ssh` berjalan normal: `sudo service ssh status`

- Gunakan [DVNA](https://github.com/appsecco/dvna) sebagai website target
  - Jalankan DVNA via Docker: `docker run --name dvna -p 9090:9090 -d appsecco/dvna:sqlite`
  - Cek image sudah jalan via Docker: `docker ps`, seharusnya ada container dengan kata kunci `dnva`
  - Cek browser di URL `http://localhost:9090`

- Setup Virtual Environment
  - buat folder virtual environment: `python -m venv web_recon_exploit`
  - pindah ke folder virtual environment: `cd web_recon_exploit`
  - Aktifkan virtual environment: `source bin/activate`
  - Install library yang diperlukan
    - `requests` untuk jalankan HTTP request: `pip install requests`
    - `argparse` untuk parsing input dengan lebih mudah dibanding `sys.argv`: `pip install argparse`
    - `scapy` untuk network sniffing: `pip install scapy`

- Setup Shodan API
  - Buat account developer di Shodan: https://account.shodan.io/register
  - Klik **show** di halaman https://account.shodan.io dan copy API key.
  - Di Kali Linux, install Shodan CLI lalu setup API key
    - `pip3 install --upgrade shodan` (asumsi sudah install Python)
    - Cek hasil instalasi dengan `shodan -h`
    - inisialisasi API key: `shodan init API_KEY` --> Jika muncul `successfully initialized`, berarti sukses.
  
### Ping Sweep

#### Define
- **Input**: -
- **Output**: laporan host yang merespon ping
- **Process**: lakukan ping secara manual pada service di range IP tertentu

#### Refine
- tentukan subnet IP
- definisikan ping serta handling
- lakukan looping untuk semua IP dalam subnet tertentu, panggil fungsi ping
- laporkan hasil ping di range yang ditentukan

#### Implement/Iterate

- Dengan pemahaman bahwa target adalah container docker, maka scanning bisa difokuskan pada IP terkait jaringan docker `172.17.x.x`
- Alternatifnya, cari dengan command berikut: `docker network inspect bridge | grep Subnet`

```python
# ping sweep.py
import subprocess
import platform
import ipaddress
from concurrent.futures import ThreadPoolExecutor

# CONFIGURATION
SUBNET = "172.17.0.0/24"  # Typical Docker bridge network
MAX_WORKERS = 10          # Speed up scan with threads

# Determine ping command depending on OS
param = "-n" if platform.system().lower() == "windows" else "-c"

def ping_host(ip):
    try:
        # Only 1 echo request with 1 second timeout
        result = subprocess.run(
            ["ping", param, "1", "-W", "1", str(ip)],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )
        if result.returncode == 0:
            print(f"[+] Host up: {ip}")
            return ip
    except Exception as e:
        print(f"Error pinging {ip}: {e}")
    return None

def sweep_subnet(subnet):
    print(f"[*] Starting ping sweep on {subnet}")
    live_hosts = []

    with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
        futures = [executor.submit(ping_host, ip) for ip in ipaddress.IPv4Network(subnet).hosts()]
        for future in futures:
            ip = future.result()
            if ip:
                live_hosts.append(ip)

    print(f"\n[*] Scan complete. {len(live_hosts)} hosts found:")
    for host in live_hosts:
        print(f" - {host}")

if __name__ == "__main__":
    sweep_subnet(SUBNET)
```

#### Validate
- pastikan jalan untuk berbagai IP subnet

#### Enhance
- Jadikan range IP sebagai input program
- simpan log ke dalam file

### Port Scanning

#### Define
- **Input**: List IP, List Port
- **Output**: List IP dan port yang terbuka
- **Process**: Cek dari list IP dan port apakah terbuka, tampilkan hasilnya untuk laporan

#### Refine
- Looping daftar IP
- Looping daftar port
- cek apakah port terbuka dengan mencoba connection
- untuk mempercepat proses, lakukan dalam thread agar bisa proses bersamaan

#### Implement/Iterate
```python
# port_scanner.py
import socket
import argparse
from concurrent.futures import ThreadPoolExecutor, as_completed

COMMON_PORTS = [22, 80, 443, 3000, 5000, 8080, 9090]
MAX_THREADS = 50

def scan_port(ip, port):
    try:
        with socket.create_connection((ip, port), timeout=1):
            return port
    except:
        return None

def scan_host(ip):
    print(f"\n[*] Scanning {ip}...")
    open_ports = []
    with ThreadPoolExecutor(max_workers=MAX_THREADS) as executor:
        futures = {executor.submit(scan_port, ip, port): port for port in COMMON_PORTS}
        for future in as_completed(futures):
            port = future.result()
            if port:
                open_ports.append(port)

    if open_ports:
        print(f"[+] {ip} - Open ports: {', '.join(map(str, open_ports))}")
    else:
        print(f"[-] {ip} - No open common ports found.")

def main():
    parser = argparse.ArgumentParser(description="Simple port scanner")
    parser.add_argument(
        "-t", "--targets",
        required=True,
        help="Comma-separated list of IP addresses (e.g. 192.168.0.1,192.168.0.2)"
    )
    args = parser.parse_args()
    ip_list = [ip.strip() for ip in args.targets.split(",")]

    for ip in ip_list:
        scan_host(ip)

if __name__ == "__main__":
    main()
```

#### Validate
- cek berbagai skenario:
  - tanpa list IP: `python3 port_scanner.py` --> ekspektasi: ditolak sistem
  - dengan list IP: `python3 port_scanner.py -t 172.17.0.1,172.17.0.2` --> ekspektasi: berhasil

#### Enhance
- simpan log ke dalam file

### SSH Brute Force

- SSH Brute Force sudah pernah dijelaskan di chapter sebelumnya dan tidak dijelaskan kembali di sini.

### Shodan API Implementation

#### Define
- **Input**: tentukan query Shodan
- **Output**: hasil pencarian Shodan
- **Process**: mengirim query ke SHodan, menangkap hasil, dan simpan dalam file.

#### Refine
- Tentukan apa yang mau dicari. Misal: cari website pemerintahan (domain `.go.id`) yang misconfigured/vulnerable.
- Kirim request ke Shodan
- Parse hasil pencarian
- Simpan di file, gunakan sebagai referensi

#### Implement/Iterate

```python
import shodan
import argparse
import datetime
from shodan.cli.helpers import get_api_key

# Setup
API_KEY = get_api_key()
FREE_TIER_SEARCH_QUERY = "go.id"
PREMIUM_SEARCH_QUERY = (
    'hostname:"go.id" '
    'ssl.cert.fingerprint.sha1:* '
    'product:"PHP" version:"5" '
    'OR product:"WordPress" '
    'OR ssl.cert.expired:true '
    'OR ssl.cert.self_signed:true'
)

MAX_RESULTS = 10  # Keep this low to save credits
LOG_FILE = "goid_vuln_sites.log"

def format_result(match):
    ip_str = match.get('ip_str', 'N/A')
    port = match.get('port', 'N/A')
    org = match.get('org', 'N/A')
    hostnames = ', '.join(match.get('hostnames', []))
    domains = ', '.join(match.get('domains', []))
    product = match.get('product', '')
    version = match.get('version', '')
    ssl_info = match.get('ssl', {})

    ssl_note = ""
    if ssl_info.get('cert'):
        cert = ssl_info.get('cert')
        expired = cert.get('expired', False)
        if expired:
            ssl_note += "EXPIRED SSL | "
        if cert.get('self_signed', False):
            ssl_note += "SELF-SIGNED SSL | "

    return f"""\
[{datetime.datetime.now().isoformat()}]
IP       : {ip_str}:{port}
Org      : {org}
Domain   : {domains}
Hostname : {hostnames}
Product  : {product} {version}
SSL Note : {ssl_note.strip()}

"""

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--api-key', help='Override SHODAN API key')
    parser.add_argument('--premium', help='use premium search if you purchase premium account')
    args = parser.parse_args()

    api_key = args.api_key if args.api_key else API_KEY
    api = shodan.Shodan(api_key)

    print("[*] Querying Shodan... This may take a few seconds.")
    try:
        search_query = PREMIUM_SEARCH_QUERY if args.premium else FREE_TIER_SEARCH_QUERY
        results = api.search(search_query, limit=MAX_RESULTS)
    except shodan.APIError as e:
        print(f"[!] API Error: {e}")
        return

    print(f"[*] Found {len(results['matches'])} results. Writing to log file: {LOG_FILE}")

    with open(LOG_FILE, "w") as f:
        for match in results['matches']:
            info = format_result(match)
            print(info)
            f.write(info + "\n")

    print("[✓] Done.")

if __name__ == "__main__":
    main()
```

#### Validate
- Jalankan untuk berbagai skenario

#### Enhance
- Pelajari filtering Shodan untuk dapatkan hasil query yang lebih baik

### Network Sniffing

#### Define
- **Input**: interface, jumlah packet
- **Output**: transmisi packet via network
- **Process**: listening packet HTTP yang berjalan di mesin

#### Refine
- handle output berupa interface dan jumlah packet
- handling interface yang di-listen
- parsing hasil tangkapan sniffing
- program berhenti jika jumlah packet tercapai. jika tidak ada batasan packet, program jalan terus.

#### Implement/Iterate

- pilih interface dengan cek command `ip a`. Opsi: `eth0`, `docker0`, dll. Untuk cek aktivitas terkait DVNA, pilih `docker0`.

```python
# network_sniffer.py
from scapy.all import sniff, TCP, IP, Raw
from datetime import datetime
import argparse

def packet_callback(packet):
    if packet.haslayer(Raw) and packet.haslayer(TCP) and packet.haslayer(IP):
        payload = packet[Raw].load.decode(errors='ignore')
        src_ip = packet[IP].src
        dst_ip = packet[IP].dst
        dport = packet[TCP].dport

        # Filter HTTP requests (port 80 or 8080)
        if dport in [80, 8080, 3000, 5000, 9090]:
            print(f"\n[+] {datetime.now()} - HTTP Packet")
            print(f"    From: {src_ip} -> To: {dst_ip}:{dport}")
            print(f"    Payload:\n{payload.strip()[:500]}")
            print("-" * 60)

def main():
    parser = argparse.ArgumentParser(description="Simple HTTP packet sniffer")
    parser.add_argument(
        "-i", "--interface", 
        required=True, 
        help="Network interface to sniff on (e.g. eth0, docker0)"
    )
    parser.add_argument(
        "-c", "--count", 
        type=int, 
        default=0, 
        help="Number of packets to capture (0 = infinite)"
    )
    args = parser.parse_args()

    print(f"[*] Starting sniff on interface: {args.interface}")
    sniff(iface=args.interface, prn=packet_callback, store=False, count=args.count)

if __name__ == "__main__":
    main()
```

#### Validate
- Jalankan untuk berbagai skenario
  - tanpa sudo: `python3 network_sniffer.py -i docker0` --> ekspektasi: gagal, operation not permitted
  - sudo + interface: `sudo python3 network_sniffer.py -i docker0` --> ekspektasi: berhasil
  - sudo tanpa interface: `sudo python3 brute_login.py --file wordlist.txt --delay 2.5` --> ekspektasi: gagal
  - sudo + interface + limit: `python3 network_sniffer.py -i docker0 -c 10` --> ekspektasi: berhasil

#### Enhance
- Buat filtering sendiri untuk ambil HTTP POST request DVNA
- Analisis payload apakah mengandung informasi sensitif

## Referensi
Registrasi Shodan: https://account.shodan.io/register
